package dataset

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/qri-io/qfs"
)

// Transform is a record of executing a transformation on data.
// Transforms can theoretically be anything from an SQL query, a jupyter
// notebook, the state of an ETL pipeline, etc, so long as the input is zero or
// more datasets, and the output is a single dataset
// Ideally, transforms should contain all the machine-necessary bits to
// deterministicly execute the algorithm referenced in "ScriptPath".
type Transform struct {
	// Config outlines any configuration that would affect the resulting hash
	Config map[string]interface{} `json:"config,omitempty"`
	// location of the transform object, transient
	Path string `json:"path,omitempty"`
	// Kind should always equal KindTransform
	Qri string `json:"qri,omitempty"`
	// Resources is a map of all datasets referenced in this transform, with
	// alphabetical keys generated by datasets in order of appearance within the
	// transform
	Resources map[string]*TransformResource `json:"resources,omitempty"`

	// script file reader, doesn't serialize
	scriptFile qfs.File
	// ScriptBytes is for representing a script as a slice of bytes, transient
	ScriptBytes []byte `json:"scriptBytes,omitempty"`
	// ScriptPath is the path to the script that produced this transformation.
	ScriptPath string `json:"scriptPath,omitempty"`
	// Secrets is a map of secret values used in the transformation, transient.
	// TODO (b5): make this not-transient by censoring the values used, but not keys
	Secrets map[string]string `json:"secrets,omitempty"`
	// Syntax this transform was written in
	Syntax string `json:"syntax,omitempty"`
	// SyntaxVersion is an identifier for the application and version number that
	// produced the result
	SyntaxVersion string `json:"syntaxVersion,omitempty"`
}

// DropTransientValues removes values that cannot be recorded when the
// dataset is rendered immutable, usually by storing it in a cafs
func (q *Transform) DropTransientValues() {
	q.Path = ""
	q.Secrets = nil
	q.ScriptBytes = nil
}

// DropDerivedValues resets all set-on-save fields to their default values
func (q *Transform) DropDerivedValues() {
	q.Qri = ""
	q.Path = ""
}

// InlineScriptFile opens the script file, reads its contents, and assigns it to
// scriptBytes
func (q *Transform) InlineScriptFile(ctx context.Context, resolver qfs.PathResolver) error {
	if resolver == nil {
		return nil
	}
	err := q.OpenScriptFile(ctx, resolver)
	if err != nil {
		return err
	}
	file := q.ScriptFile()
	if file == nil {
		return nil
	}
	data, err := ioutil.ReadAll(file)
	if err != nil {
		return err
	}
	q.ScriptBytes = data
	q.ScriptPath = ""
	return nil
}

// OpenScriptFile generates a byte stream of script data prioritizing creating an
// in-place file from ScriptBytes when defined, fetching from the
// passed-in resolver otherwise
func (q *Transform) OpenScriptFile(ctx context.Context, resolver qfs.PathResolver) (err error) {
	if q.ScriptBytes != nil {
		q.scriptFile = qfs.NewMemfileBytes("transform.star", q.ScriptBytes)
		return nil
	}

	if q.ScriptPath == "" {
		// nothing to resolve
		return nil
	}

	if resolver == nil {
		return ErrNoResolver
	}
	q.scriptFile, err = resolver.Get(ctx, q.ScriptPath)
	return err
}

// SetScriptFile assigns the scriptFile
func (q *Transform) SetScriptFile(file qfs.File) {
	q.scriptFile = file
}

// ScriptFile gives the internal file, if any. Callers that use the file in any
// way (eg. by calling Read) should consume the entire file and call Close
func (q *Transform) ScriptFile() qfs.File {
	return q.scriptFile
}

// TransformResource describes an external data dependency, the prime use case
// is for importing other datasets, but in the future this may be expanded to
// include details that specify resources other than datasets (urls?), and
// details for interpreting the resource (eg. a selector to specify only a
// subset of a resource is required)
type TransformResource struct {
	Path string `json:"path"`
}

// private version for marshalling purposes only
type transformResource TransformResource

// UnmarshalJSON implements json.Unmarshaler, allowing both string and object
// representations
func (r *TransformResource) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*r = TransformResource{Path: s}
		return nil
	}

	_r := &transformResource{}
	if err := json.Unmarshal(data, _r); err != nil {
		return err
	}

	*r = TransformResource(*_r)
	return nil
}

// NewTransformRef creates a Transform pointer with the internal
// path property specified, and no other fields.
func NewTransformRef(path string) *Transform {
	return &Transform{Path: path}
}

// IsEmpty checks to see if transform has any fields other than the internal path
func (q *Transform) IsEmpty() bool {
	return q.Config == nil &&
		q.Resources == nil &&
		q.ScriptBytes == nil &&
		q.ScriptPath == "" &&
		q.Secrets == nil &&
		q.Syntax == "" &&
		q.SyntaxVersion == ""
}

// Assign collapses all properties of a group of queries onto one.
// this is directly inspired by Javascript's Object.assign
func (q *Transform) Assign(qs ...*Transform) {
	for _, q2 := range qs {
		if q2 == nil {
			continue
		}

		if q2.Config != nil {
			if q.Config == nil {
				q.Config = map[string]interface{}{}
			}
			for key, val := range q2.Config {
				q.Config[key] = val
			}
		}
		if q2.Path != "" {
			q.Path = q2.Path
		}
		if q2.Qri != "" {
			q.Qri = q2.Qri
		}
		if q2.Resources != nil {
			if q.Resources == nil {
				q.Resources = map[string]*TransformResource{}
			}
			for key, val := range q2.Resources {
				q.Resources[key] = val
			}
		}
		if q2.scriptFile != nil {
			q.scriptFile = q2.scriptFile
		}
		if q2.ScriptBytes != nil {
			q.ScriptBytes = q2.ScriptBytes
		}
		if q2.ScriptPath != "" {
			q.ScriptPath = q2.ScriptPath
		}
		if q2.Secrets != nil {
			if q.Secrets == nil {
				q.Secrets = map[string]string{}
			}
			for key, val := range q2.Secrets {
				q.Secrets[key] = val
			}
		}
		if q2.Syntax != "" {
			q.Syntax = q2.Syntax
		}
		if q2.SyntaxVersion != "" {
			q.SyntaxVersion = q2.SyntaxVersion
		}
	}
}

// _transform is a private struct for marshaling into & out of.
// fields must remain sorted in lexographical order
type _transform Transform

// MarshalJSON satisfies the json.Marshaler interface
func (q Transform) MarshalJSON() ([]byte, error) {
	// if we're dealing with an empty object that has a path specified, marshal to a string instead
	if q.Path != "" && q.IsEmpty() {
		return json.Marshal(q.Path)
	}
	return q.MarshalJSONObject()
}

// MarshalJSONObject always marshals to a json Object, even if meta is empty or a reference
func (q Transform) MarshalJSONObject() ([]byte, error) {
	kind := q.Qri
	if kind == "" {
		kind = KindTransform.String()
	}

	return json.Marshal(&_transform{
		Config:        q.Config,
		Path:          q.Path,
		Qri:           kind,
		Resources:     q.Resources,
		ScriptBytes:   q.ScriptBytes,
		ScriptPath:    q.ScriptPath,
		Syntax:        q.Syntax,
		SyntaxVersion: q.SyntaxVersion,
	})
}

// UnmarshalJSON satisfies the json.Unmarshaler interface
func (q *Transform) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*q = Transform{Path: s}
		return nil
	}

	_q := _transform{}
	if err := json.Unmarshal(data, &_q); err != nil {
		return err
	}

	*q = Transform(_q)
	return nil
}

// UnmarshalTransform tries to extract a resource type from an empty
// interface. Pairs nicely with datastore.Get() from github.com/ipfs/go-datastore
func UnmarshalTransform(v interface{}) (*Transform, error) {
	switch q := v.(type) {
	case *Transform:
		return q, nil
	case Transform:
		return &q, nil
	case []byte:
		transform := &Transform{}
		err := json.Unmarshal(q, transform)
		return transform, err
	default:
		err := fmt.Errorf("couldn't parse transform")
		return nil, err
	}
}
